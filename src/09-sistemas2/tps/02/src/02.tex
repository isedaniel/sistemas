\section{Mantenimiento}

El desarrollo de software de calidad se sostiene,
a grandes rasgos, en dos pilares principales:
el \textbf{análisis}, que implica el conocimiento en detalle de la situación 
o problema a resolver; y del \textbf{diseño} de una solución correctamente 
estructurada, de una arquitectura lógica y sustentable.

El software de calidad es más \textbf{comprensible} y, 
como afirma Pressman citando a Berns, 
mantinibilidad y comprensión son conceptos paralelos:
un programa difícil de entender es difícil de mantener.

Pero, ¿a qué refiere concretamente la \textbf{mantenibilidad}?
El autor la define como un \textit{indicio cualitativo}
de la \textit{facilidad} con que una pieza de software puede
\textbf{corregirse, adaptarse o aumentarse}.

El autor distingue también factores que incrementan la mantenibilidad.
\begin{itemize}
    \item \textbf{Modularidad},
    que es la división de una aplicación en componentes distinguibles,
    que se pueden trabajar por separado y que, 
    actuando de manera conjunta, 
    resuelven un problema concreto.
    \item \textbf{Uso de patrones de diseño},
    que refiere a un conjunto de soluciones concretas a problemas recurrentes
    en el desarrollo de software.
    \item \textbf{Uso de estándares},
    que conducen a código legible, autodocumentable y comprensible.
\end{itemize}

Por último, factores que suelen ir en detrimento de la matenibilidad:

\begin{itemize}
    \item El software de legado, construido en un contexto en que 
    el \textbf{tamaño del programa} y el \textbf{espacio de almacenamiento}
    eran las preocupaciones principales, lo que conducía con frecuencia a 
    diseños que iban en detrimento de la \textbf{arquitectura del software},
    dificultando comprensión y, por lo tanto, la mantenibilidad.
    \item \textbf{Movilidad del personal},
    que refiere a la entrada y salida de profesionales o equipos de la 
    organización, que inclusive puede agravarse,
    en la medida en que diversas generaciones de ingenieros trabajen en el 
    desarrollo y mantenimiento del mismo software,
    cada uno con sus propios criterios,
    yendo en detrimento tanto de la familiaridad con el sistema como con 
    la capacidad de comprenderlo en su conjunto.
\end{itemize}